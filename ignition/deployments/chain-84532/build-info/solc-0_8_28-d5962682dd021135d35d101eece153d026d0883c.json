{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-d5962682dd021135d35d101eece153d026d0883c",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/ValidationRegistry.sol": "project/contracts/ValidationRegistry.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/interfaces/IIdentityRegistry.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/**\n * @title IIdentityRegistry\n * @dev Interface for the Identity Registry as defined in ERC-XXXX Trustless Agents v0.3\n * @notice This contract serves as the central registry for all agent identities\n */\ninterface IIdentityRegistry {\n    // ============ Events ============\n    \n    /**\n     * @dev Emitted when a new agent is registered\n     */\n    event AgentRegistered(uint256 indexed agentId, string agentDomain, address agentAddress);\n    \n    /**\n     * @dev Emitted when an agent's information is updated\n     */\n    event AgentUpdated(uint256 indexed agentId, string agentDomain, address agentAddress);\n\n    // ============ Structs ============\n    \n    /**\n     * @dev Agent information structure\n     */\n    struct AgentInfo {\n        uint256 agentId;\n        string agentDomain;\n        address agentAddress;\n    }\n\n    // ============ Errors ============\n    \n    error AgentNotFound();\n    error UnauthorizedUpdate();\n    error InvalidDomain();\n    error InvalidAddress();\n    error InsufficientFee();\n    error DomainAlreadyRegistered();\n    error AddressAlreadyRegistered();\n\n    // ============ Write Functions ============\n    \n    /**\n     * @dev Register a new agent\n     * @param agentDomain The domain where the agent's AgentCard is hosted\n     * @param agentAddress The EVM address of the agent\n     * @return agentId The unique identifier assigned to the agent\n     * @notice Requires 0.005 ETH fee which is burned\n     */\n    function newAgent(string calldata agentDomain, address agentAddress) external payable returns (uint256 agentId);\n    \n    /**\n     * @dev Update an existing agent's information\n     * @param agentId The agent's unique identifier\n     * @param newAgentDomain New domain (empty string to keep current)\n     * @param newAgentAddress New address (zero address to keep current)\n     * @return success True if update was successful\n     * @notice Only callable by the agent's current address or authorized delegate\n     */\n    function updateAgent(\n        uint256 agentId, \n        string calldata newAgentDomain, \n        address newAgentAddress\n    ) external returns (bool success);\n\n    // ============ Read Functions ============\n    \n    /**\n     * @dev Get agent information by ID\n     * @param agentId The agent's unique identifier\n     * @return agentInfo The agent's information\n     */\n    function getAgent(uint256 agentId) external view returns (AgentInfo memory agentInfo);\n    \n    /**\n     * @dev Resolve agent by domain\n     * @param agentDomain The agent's domain\n     * @return agentInfo The agent's information\n     */\n    function resolveByDomain(string calldata agentDomain) external view returns (AgentInfo memory agentInfo);\n    \n    /**\n     * @dev Resolve agent by address\n     * @param agentAddress The agent's address\n     * @return agentInfo The agent's information\n     */\n    function resolveByAddress(address agentAddress) external view returns (AgentInfo memory agentInfo);\n    \n    /**\n     * @dev Get the total number of registered agents\n     * @return count The total count of registered agents\n     */\n    function getAgentCount() external view returns (uint256 count);\n    \n    /**\n     * @dev Check if an agent ID exists\n     * @param agentId The agent ID to check\n     * @return exists True if the agent exists\n     */\n    function agentExists(uint256 agentId) external view returns (bool exists);\n\n    // ============ Constants ============\n    \n    /**\n     * @dev Registration fee in wei (0.005 ETH)\n     * @return fee The registration fee\n     */\n    function REGISTRATION_FEE() external pure returns (uint256 fee);\n}\n"
      },
      "project/contracts/interfaces/IValidationRegistry.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/**\n * @title IValidationRegistry\n * @dev Interface for the Validation Registry as defined in ERC-XXXX Trustless Agents v0.3\n * @notice This contract provides hooks for requesting and recording independent validation\n */\ninterface IValidationRegistry {\n    // ============ Events ============\n    \n    /**\n     * @dev Emitted when a validation request is made\n     */\n    event ValidationRequestEvent(\n        uint256 indexed agentValidatorId,\n        uint256 indexed agentServerId,\n        bytes32 indexed dataHash\n    );\n    \n    /**\n     * @dev Emitted when a validation response is submitted\n     */\n    event ValidationResponseEvent(\n        uint256 indexed agentValidatorId,\n        uint256 indexed agentServerId,\n        bytes32 indexed dataHash,\n        uint8 response\n    );\n\n    // ============ Structs ============\n    \n    /**\n     * @dev Validation request structure\n     */\n    struct Request {\n        uint256 agentValidatorId;\n        uint256 agentServerId;\n        bytes32 dataHash;\n        uint256 timestamp;\n        bool responded;\n    }\n\n    // ============ Errors ============\n    \n    error AgentNotFound();\n    error ValidationRequestNotFound();\n    error ValidationAlreadyResponded();\n    error UnauthorizedValidator();\n    error RequestExpired();\n    error InvalidResponse();\n    error InvalidDataHash();\n\n    // ============ Write Functions ============\n    \n    /**\n     * @dev Submit a validation request\n     * @param agentValidatorId The ID of the validator agent\n     * @param agentServerId The ID of the server agent whose work needs validation\n     * @param dataHash Hash of the data to be validated\n     * @notice Creates a validation request that can be responded to by the validator\n     */\n    function validationRequest(\n        uint256 agentValidatorId,\n        uint256 agentServerId,\n        bytes32 dataHash\n    ) external;\n    \n    /**\n     * @dev Submit a validation response\n     * @param dataHash Hash of the data that was validated\n     * @param response Validation score (0-100)\n     * @notice Only callable by the designated validator agent's address\n     */\n    function validationResponse(bytes32 dataHash, uint8 response) external;\n\n    // ============ Read Functions ============\n    \n    /**\n     * @dev Get validation request details\n     * @param dataHash The hash of the data being validated\n     * @return request The validation request details\n     */\n    function getValidationRequest(bytes32 dataHash) external view returns (Request memory request);\n    \n    /**\n     * @dev Check if a validation request exists and is pending\n     * @param dataHash The hash of the data being validated\n     * @return exists True if the request exists\n     * @return pending True if the request is still pending response\n     */\n    function isValidationPending(bytes32 dataHash) external view returns (bool exists, bool pending);\n    \n    /**\n     * @dev Get the validation response for a data hash\n     * @param dataHash The hash of the validated data\n     * @return hasResponse True if a response exists\n     * @return response The validation score (0-100)\n     */\n    function getValidationResponse(bytes32 dataHash) external view returns (bool hasResponse, uint8 response);\n    \n    /**\n     * @dev Get the expiration time for validation requests\n     * @return slots Number of storage slots a request remains valid\n     */\n    function getExpirationSlots() external view returns (uint256 slots);\n}\n"
      },
      "project/contracts/ValidationRegistry.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"./interfaces/IValidationRegistry.sol\";\nimport \"./interfaces/IIdentityRegistry.sol\";\n\n/**\n * @title ValidationRegistry\n * @dev Implementation of the Validation Registry for ERC-XXXX Trustless Agents v0.3\n * @notice Provides hooks for requesting and recording independent validation\n * @author ChaosChain Labs\n */\ncontract ValidationRegistry is IValidationRegistry {\n    // ============ Constants ============\n    \n    /// @dev Number of storage slots a validation request remains valid (default: 1000 blocks)\n    uint256 public constant EXPIRATION_SLOTS = 1000;\n\n    // ============ State Variables ============\n    \n    /// @dev Reference to the IdentityRegistry for agent validation\n    IIdentityRegistry public immutable identityRegistry;\n    \n    /// @dev Mapping from data hash to validation request\n    mapping(bytes32 => IValidationRegistry.Request) private _validationRequests;\n    \n    /// @dev Mapping from data hash to validation response\n    mapping(bytes32 => uint8) private _validationResponses;\n    \n    /// @dev Mapping from data hash to whether a response exists\n    mapping(bytes32 => bool) private _hasResponse;\n\n    // ============ Constructor ============\n    \n    /**\n     * @dev Constructor sets the identity registry reference\n     * @param _identityRegistry Address of the IdentityRegistry contract\n     */\n    constructor(address _identityRegistry) {\n        identityRegistry = IIdentityRegistry(_identityRegistry);\n    }\n\n    // ============ Write Functions ============\n    \n    /**\n     * @inheritdoc IValidationRegistry\n     */\n    function validationRequest(\n        uint256 agentValidatorId,\n        uint256 agentServerId,\n        bytes32 dataHash\n    ) external {\n        // Validate inputs\n        if (dataHash == bytes32(0)) {\n            revert InvalidDataHash();\n        }\n        \n        // Validate that both agents exist\n        if (!identityRegistry.agentExists(agentValidatorId)) {\n            revert AgentNotFound();\n        }\n        if (!identityRegistry.agentExists(agentServerId)) {\n            revert AgentNotFound();\n        }\n        \n        // Check if request already exists and is still valid\n        IValidationRegistry.Request storage existingRequest = _validationRequests[dataHash];\n        if (existingRequest.dataHash != bytes32(0)) {\n            if (block.number <= existingRequest.timestamp + EXPIRATION_SLOTS) {\n                // Request still exists and is valid, just emit the event again\n                emit ValidationRequestEvent(agentValidatorId, agentServerId, dataHash);\n                return;\n            }\n        }\n        \n        // Create new validation request\n        _validationRequests[dataHash] = IValidationRegistry.Request({\n            agentValidatorId: agentValidatorId,\n            agentServerId: agentServerId,\n            dataHash: dataHash,\n            timestamp: block.number,\n            responded: false\n        });\n        \n        emit ValidationRequestEvent(agentValidatorId, agentServerId, dataHash);\n    }\n    \n    /**\n     * @inheritdoc IValidationRegistry\n     */\n    function validationResponse(bytes32 dataHash, uint8 response) external {\n        // Validate response range (0-100)\n        if (response > 100) {\n            revert InvalidResponse();\n        }\n        \n        // Get the validation request\n        IValidationRegistry.Request storage request = _validationRequests[dataHash];\n        \n        // Check if request exists\n        if (request.dataHash == bytes32(0)) {\n            revert ValidationRequestNotFound();\n        }\n        \n        // Check if request has expired\n        if (block.number > request.timestamp + EXPIRATION_SLOTS) {\n            revert RequestExpired();\n        }\n        \n        // Check if already responded\n        if (request.responded) {\n            revert ValidationAlreadyResponded();\n        }\n        \n        // Get validator agent info to check authorization\n        IIdentityRegistry.AgentInfo memory validatorAgent = identityRegistry.getAgent(request.agentValidatorId);\n        \n        // Only the designated validator can respond\n        if (msg.sender != validatorAgent.agentAddress) {\n            revert UnauthorizedValidator();\n        }\n        \n        // Mark as responded and store the response\n        request.responded = true;\n        _validationResponses[dataHash] = response;\n        _hasResponse[dataHash] = true;\n        \n        emit ValidationResponseEvent(request.agentValidatorId, request.agentServerId, dataHash, response);\n    }\n\n    // ============ Read Functions ============\n    \n    /**\n     * @inheritdoc IValidationRegistry\n     */\n    function getValidationRequest(bytes32 dataHash) external view returns (IValidationRegistry.Request memory request) {\n        request = _validationRequests[dataHash];\n        if (request.dataHash == bytes32(0)) {\n            revert ValidationRequestNotFound();\n        }\n    }\n    \n    /**\n     * @inheritdoc IValidationRegistry\n     */\n    function isValidationPending(bytes32 dataHash) external view returns (bool exists, bool pending) {\n        IValidationRegistry.Request storage request = _validationRequests[dataHash];\n        exists = request.dataHash != bytes32(0);\n        \n        if (exists) {\n            // Check if not expired and not responded\n            bool expired = block.number > request.timestamp + EXPIRATION_SLOTS;\n            pending = !expired && !request.responded;\n        }\n    }\n    \n    /**\n     * @inheritdoc IValidationRegistry\n     */\n    function getValidationResponse(bytes32 dataHash) external view returns (bool hasResponse, uint8 response) {\n        hasResponse = _hasResponse[dataHash];\n        if (hasResponse) {\n            response = _validationResponses[dataHash];\n        }\n    }\n    \n    /**\n     * @inheritdoc IValidationRegistry\n     */\n    function getExpirationSlots() external pure returns (uint256 slots) {\n        return EXPIRATION_SLOTS;\n    }\n}\n"
      }
    }
  }
}