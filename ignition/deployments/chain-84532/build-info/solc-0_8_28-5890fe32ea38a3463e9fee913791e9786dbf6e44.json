{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-5890fe32ea38a3463e9fee913791e9786dbf6e44",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/ReputationRegistry.sol": "project/contracts/ReputationRegistry.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/interfaces/IIdentityRegistry.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/**\n * @title IIdentityRegistry\n * @dev Interface for the Identity Registry as defined in ERC-XXXX Trustless Agents v0.3\n * @notice This contract serves as the central registry for all agent identities\n */\ninterface IIdentityRegistry {\n    // ============ Events ============\n    \n    /**\n     * @dev Emitted when a new agent is registered\n     */\n    event AgentRegistered(uint256 indexed agentId, string agentDomain, address agentAddress);\n    \n    /**\n     * @dev Emitted when an agent's information is updated\n     */\n    event AgentUpdated(uint256 indexed agentId, string agentDomain, address agentAddress);\n\n    // ============ Structs ============\n    \n    /**\n     * @dev Agent information structure\n     */\n    struct AgentInfo {\n        uint256 agentId;\n        string agentDomain;\n        address agentAddress;\n    }\n\n    // ============ Errors ============\n    \n    error AgentNotFound();\n    error UnauthorizedUpdate();\n    error InvalidDomain();\n    error InvalidAddress();\n    error InsufficientFee();\n    error DomainAlreadyRegistered();\n    error AddressAlreadyRegistered();\n\n    // ============ Write Functions ============\n    \n    /**\n     * @dev Register a new agent\n     * @param agentDomain The domain where the agent's AgentCard is hosted\n     * @param agentAddress The EVM address of the agent\n     * @return agentId The unique identifier assigned to the agent\n     * @notice Requires 0.005 ETH fee which is burned\n     */\n    function newAgent(string calldata agentDomain, address agentAddress) external payable returns (uint256 agentId);\n    \n    /**\n     * @dev Update an existing agent's information\n     * @param agentId The agent's unique identifier\n     * @param newAgentDomain New domain (empty string to keep current)\n     * @param newAgentAddress New address (zero address to keep current)\n     * @return success True if update was successful\n     * @notice Only callable by the agent's current address or authorized delegate\n     */\n    function updateAgent(\n        uint256 agentId, \n        string calldata newAgentDomain, \n        address newAgentAddress\n    ) external returns (bool success);\n\n    // ============ Read Functions ============\n    \n    /**\n     * @dev Get agent information by ID\n     * @param agentId The agent's unique identifier\n     * @return agentInfo The agent's information\n     */\n    function getAgent(uint256 agentId) external view returns (AgentInfo memory agentInfo);\n    \n    /**\n     * @dev Resolve agent by domain\n     * @param agentDomain The agent's domain\n     * @return agentInfo The agent's information\n     */\n    function resolveByDomain(string calldata agentDomain) external view returns (AgentInfo memory agentInfo);\n    \n    /**\n     * @dev Resolve agent by address\n     * @param agentAddress The agent's address\n     * @return agentInfo The agent's information\n     */\n    function resolveByAddress(address agentAddress) external view returns (AgentInfo memory agentInfo);\n    \n    /**\n     * @dev Get the total number of registered agents\n     * @return count The total count of registered agents\n     */\n    function getAgentCount() external view returns (uint256 count);\n    \n    /**\n     * @dev Check if an agent ID exists\n     * @param agentId The agent ID to check\n     * @return exists True if the agent exists\n     */\n    function agentExists(uint256 agentId) external view returns (bool exists);\n\n    // ============ Constants ============\n    \n    /**\n     * @dev Registration fee in wei (0.005 ETH)\n     * @return fee The registration fee\n     */\n    function REGISTRATION_FEE() external pure returns (uint256 fee);\n}\n"
      },
      "project/contracts/interfaces/IReputationRegistry.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/**\n * @title IReputationRegistry\n * @dev Interface for the Reputation Registry as defined in ERC-XXXX Trustless Agents v0.3\n * @notice This contract provides a lightweight entry point for task feedback between agents\n */\ninterface IReputationRegistry {\n    // ============ Events ============\n    \n    /**\n     * @dev Emitted when feedback is authorized for a client-server pair\n     */\n    event AuthFeedback(\n        uint256 indexed agentClientId,\n        uint256 indexed agentServerId,\n        bytes32 indexed feedbackAuthId\n    );\n\n    // ============ Errors ============\n    \n    error AgentNotFound();\n    error UnauthorizedFeedback();\n    error FeedbackAlreadyAuthorized();\n    error InvalidAgentId();\n\n    // ============ Write Functions ============\n    \n    /**\n     * @dev Accept feedback authorization from a client agent\n     * @param agentClientId The ID of the client agent who will provide feedback\n     * @param agentServerId The ID of the server agent who will receive feedback\n     * @notice This creates a unique authorization for the client to provide feedback\n     * @notice Only callable by the server agent's registered address\n     */\n    function acceptFeedback(uint256 agentClientId, uint256 agentServerId) external;\n\n    // ============ Read Functions ============\n    \n    /**\n     * @dev Check if feedback is authorized for a client-server pair\n     * @param agentClientId The client agent ID\n     * @param agentServerId The server agent ID\n     * @return isAuthorized True if feedback is authorized\n     * @return feedbackAuthId The unique authorization ID if authorized\n     */\n    function isFeedbackAuthorized(\n        uint256 agentClientId, \n        uint256 agentServerId\n    ) external view returns (bool isAuthorized, bytes32 feedbackAuthId);\n    \n    /**\n     * @dev Get the feedback authorization ID for a client-server pair\n     * @param agentClientId The client agent ID\n     * @param agentServerId The server agent ID\n     * @return feedbackAuthId The unique authorization ID\n     */\n    function getFeedbackAuthId(\n        uint256 agentClientId, \n        uint256 agentServerId\n    ) external view returns (bytes32 feedbackAuthId);\n}\n"
      },
      "project/contracts/ReputationRegistry.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"./interfaces/IReputationRegistry.sol\";\nimport \"./interfaces/IIdentityRegistry.sol\";\n\n/**\n * @title ReputationRegistry\n * @dev Implementation of the Reputation Registry for ERC-XXXX Trustless Agents v0.3\n * @notice Lightweight entry point for task feedback between agents\n * @author ChaosChain Labs\n */\ncontract ReputationRegistry is IReputationRegistry {\n    // ============ State Variables ============\n    \n    /// @dev Reference to the IdentityRegistry for agent validation\n    IIdentityRegistry public immutable identityRegistry;\n    \n    /// @dev Mapping from feedback auth ID to whether it exists\n    mapping(bytes32 => bool) private _feedbackAuthorizations;\n    \n    /// @dev Mapping from client-server pair to feedback auth ID\n    mapping(uint256 => mapping(uint256 => bytes32)) private _clientServerToAuthId;\n\n    // ============ Constructor ============\n    \n    /**\n     * @dev Constructor sets the identity registry reference\n     * @param _identityRegistry Address of the IdentityRegistry contract\n     */\n    constructor(address _identityRegistry) {\n        identityRegistry = IIdentityRegistry(_identityRegistry);\n    }\n\n    // ============ Write Functions ============\n    \n    /**\n     * @inheritdoc IReputationRegistry\n     */\n    function acceptFeedback(uint256 agentClientId, uint256 agentServerId) external {\n        // Validate that both agents exist\n        if (!identityRegistry.agentExists(agentClientId)) {\n            revert AgentNotFound();\n        }\n        if (!identityRegistry.agentExists(agentServerId)) {\n            revert AgentNotFound();\n        }\n        \n        // Get server agent info to check authorization\n        IIdentityRegistry.AgentInfo memory serverAgent = identityRegistry.getAgent(agentServerId);\n        \n        // Only the server agent can authorize feedback\n        if (msg.sender != serverAgent.agentAddress) {\n            revert UnauthorizedFeedback();\n        }\n        \n        // Check if feedback is already authorized\n        bytes32 existingAuthId = _clientServerToAuthId[agentClientId][agentServerId];\n        if (existingAuthId != bytes32(0)) {\n            revert FeedbackAlreadyAuthorized();\n        }\n        \n        // Generate unique feedback authorization ID\n        bytes32 feedbackAuthId = _generateFeedbackAuthId(agentClientId, agentServerId);\n        \n        // Store the authorization\n        _feedbackAuthorizations[feedbackAuthId] = true;\n        _clientServerToAuthId[agentClientId][agentServerId] = feedbackAuthId;\n        \n        emit AuthFeedback(agentClientId, agentServerId, feedbackAuthId);\n    }\n\n    // ============ Read Functions ============\n    \n    /**\n     * @inheritdoc IReputationRegistry\n     */\n    function isFeedbackAuthorized(\n        uint256 agentClientId,\n        uint256 agentServerId\n    ) external view returns (bool isAuthorized, bytes32 feedbackAuthId) {\n        feedbackAuthId = _clientServerToAuthId[agentClientId][agentServerId];\n        isAuthorized = feedbackAuthId != bytes32(0) && _feedbackAuthorizations[feedbackAuthId];\n    }\n    \n    /**\n     * @inheritdoc IReputationRegistry\n     */\n    function getFeedbackAuthId(\n        uint256 agentClientId,\n        uint256 agentServerId\n    ) external view returns (bytes32 feedbackAuthId) {\n        feedbackAuthId = _clientServerToAuthId[agentClientId][agentServerId];\n    }\n\n    // ============ Internal Functions ============\n    \n    /**\n     * @dev Generates a unique feedback authorization ID\n     * @param agentClientId The client agent ID\n     * @param agentServerId The server agent ID\n     * @return feedbackAuthId The unique authorization ID\n     */\n    function _generateFeedbackAuthId(\n        uint256 agentClientId,\n        uint256 agentServerId\n    ) private view returns (bytes32 feedbackAuthId) {\n        // Include block timestamp and transaction hash for uniqueness\n        feedbackAuthId = keccak256(\n            abi.encodePacked(\n                agentClientId,\n                agentServerId,\n                block.timestamp,\n                block.difficulty, // Use block.difficulty for additional entropy\n                tx.origin\n            )\n        );\n    }\n}\n"
      }
    }
  }
}